#!/usr/bin/env python3

import sys, os, re

name_rx = re.compile(r"([a-zA-Z0-9_]+)\s*;")

def upper_first(s):
    if s == "": return
    return s[0].upper() + s[1:]

def preprocess_file(inpath, code, attrs, uniforms, current):
    with open(inpath, "r") as infile:
        for line in infile:
            stripped = line.strip()
            if stripped == "// @Vertex":
                current = "vertex"
            elif stripped == "// @Fragment":
                current = "fragment"
            elif stripped.startswith("// @Include "):
                include = stripped[12:]
                preprocess_file(
                    os.path.join(os.path.dirname(inpath), include), code,
                    attrs, uniforsm, current)
            elif stripped.startswith("// @"):
                raise Exception("Unexpected pragma:", stripped)
            elif stripped.startswith("in ") and current == "vertex":
                name = name_rx.search(stripped).group(1)
                attrs.add(name)
                code[current] += line
            elif stripped.startswith("uniform "):
                name = name_rx.search(stripped).group(1)
                uniforms.add(name)
                code[current] += line
            else:
                code[current] += line

def write_c_string(s, f, pfx = "\n\t"):
    if s == "":
        f.write(pfx)
        f.write("\"\"\n")
        return

    in_str = False
    for ch in s.encode("utf-8"):
        if not in_str:
            f.write(pfx)
            f.write("\"")
            in_str = True

        if ch == ord("\""):
            f.write("\\\"")
        elif ch == ord("\\"):
            f.write("\\")
        elif ch == ord("\n"):
            f.write("\\n\"")
            in_str = False
        elif ch == ord("\r"):
            f.write("\\r")
        elif ch == ord("\t"):
            f.write("\\t")
        elif ch < 32 or ch > 126:
            f.write(f"\\x{ch:02x}")
        else:
            f.write(chr(ch))

def preprocess(inpath, hfile, ccfile):
    file_name = os.path.basename(inpath)
    struct_name = os.path.splitext(file_name)[0]

    code = {
        "common": "",
        "vertex": "",
        "fragment": "",
    }

    attrs = set()
    uniforms = set()
    preprocess_file(inpath, code, attrs, uniforms, "common")

    hfile.write(f"// Generated by shaderpp.py from {inpath}\n\n")
    hfile.write("#pragma once\n\n")
    hfile.write("#include <cygnet/gl.h>\n\n")
    hfile.write("namespace Cygnet {\nnamespace Shader {\n\n")

    hfile.write(f"struct {struct_name} {{\n")
    hfile.write(f"\t{struct_name}(GLuint id);\n\n")
    hfile.write(f"\tstatic constexpr const char *name = \"{file_name}\";\n\n")
    hfile.write("\tstatic const char vertex[];\n");
    hfile.write("\tstatic const char fragment[];\n");

    fields = []
    for attr in attrs:
        fields.append((attr, f"attr{upper_first(attr)}", "glGetAttribLocation"))
    for uniform in uniforms:
        fields.append((uniform, f"uni{upper_first(uniform)}", "glGetUniformLocation"))
    fields.sort()

    if len(fields) > 0:
        hfile.write("\n")
        for field in fields:
            hfile.write(f"\tconst GLint {field[1]};\n")

    hfile.write("};\n")

    hfile.write("\n}\n}\n")

    ccfile.write(f"// Generated by shaderpp.py from {inpath}\n\n")
    ccfile.write(f"#include \"{os.path.basename(hfile.name)}\"\n\n")
    ccfile.write("namespace Cygnet {\nnamespace Shader {\n\n")

    ccfile.write(f"{struct_name}::{struct_name}(GLuint id)")
    first_field = True
    for field in fields:
        if first_field:
            ccfile.write(":")
            first_field = False
        else:
            ccfile.write(",")
        ccfile.write(f"\n\t{field[1]}({field[2]}(id, \"{field[0]}\"))")
    ccfile.write(" {}\n\n")

    ccfile.write(f"const char {struct_name}::vertex[] =")
    write_c_string(
        "// Common\n" +
        code["common"] +
        "// Vertex\n" +
        code["vertex"],
        ccfile)
    ccfile.write(";\n")

    ccfile.write("\n")

    ccfile.write(f"const char {struct_name}::fragment[] =")
    write_c_string(
        "// Common\n" +
        code["common"] +
        "// Fragment\n" +
        code["fragment"],
        ccfile)
    ccfile.write(";\n")

    ccfile.write("\n}\n}\n")

inpath = sys.argv[1]
hpath = sys.argv[2]
ccpath = sys.argv[3]

hfile = open(hpath, "w")
ccfile = open(ccpath, "w")
try:
    preprocess(inpath, hfile, ccfile)
except Exception as ex:
    os.remove(ccpath)
    os.remove(hpath)
    raise ex
finally:
    ccfile.close()
    hfile.close()
